{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/1984/12/17/hello-world/"},{"title":"Protobuf Speed Optimization","text":"Original CodePacketMap1234567891011public void Initialize(){ foreach (FieldDescriptor fieldDescriptor in Messages.Descriptor.Fields.InDeclarationOrder()) { ushort messageType = (ushort)fieldDescriptor.FieldNumber; _messageTypes[fieldDescriptor.MessageType.ClrType] = messageType; _parsers[messageType] = fieldDescriptor.MessageType.Parser; }} 优化前的问题 在游戏启动后直接加载中这段代码 可以看到这段代码耗时在User Code中占用了一半，在真机表现中，因为是在游戏启动后直接加载这段代码，所以在logo出现后会黑屏一会再出现loading界面。 优化版本1 代码耗时的最大原因是Protobuf的反射问题，所以能不能不用反射呢。优化方向有两个 不放在游戏启动时进行，而是在loading时进行 不用反射 下面是优化后的代码 PacketMapLoader1234567891011121314151617181920212223public class PacketMapLoader : ILaunchTask{ [Inject] private readonly IPacketMap _packetMap; public int ExecuteOrder => -1; public async UniTask Execute() { var stopwatch = new Stopwatch(); stopwatch.Start(); var messageTypes = new Dictionary(); var parsers = new Dictionary(); var packetMapData = new PacketMapData(); packetMapData.Init(messageTypes, parsers); _packetMap.InitMessages(messageTypes, parsers); stopwatch.Stop(); Debug.LogFormat( $\"PacketMapLoader Execute cost:{stopwatch.Elapsed.TotalMilliseconds}\"); }}再来看看时间是不是省了非常多，从500ms多到90ms。 那么是怎么做到的呢，原因就是提前生成需要的代码来代替反射。这里大概有200多个网络消息，创建PacketMapData的代码我放最下面。 PacketMapData1234567891011121314public class PacketMapData{ public void Init(Dictionary messageTypes, Dictionary parsers) { messageTypes.Add(typeof(Protocols.Messages.Login.LoginToLSReq), 1001); var parser1 = Protocols.Messages.Login.LoginToLSReq.Parser; parsers.Add(1001, parser1); ... ... messageTypes.Add(typeof(Protocols.Messages.Activity.NewYearBuyRes), 2601); var parser254 = Protocols.Messages.Activity.NewYearBuyRes.Parser; parsers.Add(2601, parser254); }} 不足:但是实际上这段代码还是有不足的地方，比如loading开始时会有一点点卡顿。原因可以看以下Protobuf源码 当我们每次获取消息的Parser时都会进行一遍new操作，比如 1var parser1 = Protocols.Messages.Login.LoginToLSReq.Parser; 而且我们有200多个消息，这也是可以优化的，优化方向就是异步处理。 异步优化版本 优化的重点就是用异步来做，但是时间总耗时增加了很多，所以用哪个看项目需要。 PacketMapLoader1234567891011121314151617181920212223public class PacketMapLoader : ILaunchTask{ [Inject] private readonly IPacketMap _packetMap; public int ExecuteOrder => -1; public async UniTask Execute() { var stopwatch = new Stopwatch(); stopwatch.Start(); var messageTypes = new Dictionary(); var parsers = new Dictionary(); var packetMapData = new PacketMapData(); await UniTask.WhenAll(packetMapData.Init(messageTypes, parsers)); _packetMap.InitMessages(messageTypes, parsers); stopwatch.Stop(); Debug.LogFormat( $\"PacketMapLoader Execute cost:{stopwatch.Elapsed.TotalMilliseconds}\"); }} PacketMapData1234567891011121314151617public class PacketMapData{ public async UniTask Init(Dictionary messageTypes, Dictionary parsers) { messageTypes.Add(typeof(Protocols.Messages.Login.LoginToLSReq), 1001); var parser1 = Protocols.Messages.Login.LoginToLSReq.Parser; parsers.Add(1001, parser1); await UniTask.WaitUntil(() => parser1 != null); ... ... messageTypes.Add(typeof(Protocols.Messages.Activity.NewYearBuyRes), 2601); var parser254 = Protocols.Messages.Activity.NewYearBuyRes.Parser; parsers.Add(2601, parser254); await UniTask.WaitUntil(() => parser254 != null); }} 这个异步优化代码也有可以优化的空间，每次都等异步太浪费了，增加了耗时，最好是打包几个消息确定具体时间后异步等对应时间可能会更好。 PacketMapCreate1234567891011121314151617181920[MenuItem(\"Tools/PacketMapCreate\")]public static void Create(){ var csText = Header; var index = 0; foreach (FieldDescriptor fieldDescriptor in Messages.Descriptor.Fields.InDeclarationOrder()) { csText += $\"\\t\\t\\tmessageTypes.Add(typeof({fieldDescriptor.MessageType.ClrType.FullName}), {fieldDescriptor.FieldNumber});\\n\"; var parser = $\"parser{++index}\"; csText += $\"\\t\\t\\tvar {parser} = {fieldDescriptor.MessageType.ClrType.FullName + \".Parser\"};\\n\"; csText += $\"\\t\\t\\tparsers.Add({fieldDescriptor.FieldNumber}, {parser});\\n\";// csText += $\"\\t\\t\\tawait UniTask.WaitUntil(() => {parser} != null);\\n\"; csText += \"\\n\"; } csText += Bottom; var path = Path.Combine(Application.dataPath, \"PuzzlesKingdom/Scripts/PacketMap/PacketMapData.cs\"); File.WriteAllText(path, csText);}","link":"/2019/12/31/Protobuf-Speed-Optimization/"},{"title":"Why change typecho to hexo","text":"Test","link":"/2019/06/02/Why-change-typecho-to-hexo/"}],"tags":[],"categories":[]}