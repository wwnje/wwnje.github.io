<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Protobuf Speed Optimization - wwnje</title>
    <meta property="og:title" content="Protobuf Speed Optimization - wwnje">
    
    <meta name="twitter:card" content="summary">

    
      
    

    
      
      <meta property="description" content="optimization  Messages.Descriptor.Fields.InDeclarationOrder()
[&amp;hellip;] public void Initialize(){foreach (FieldDescriptor fieldDescriptorin Messages.Descriptor.Fields.InDeclarationOrder()){ &amp;hellip;">
      <meta property="og:description" content="optimization  Messages.Descriptor.Fields.InDeclarationOrder()
[&amp;hellip;] public void Initialize(){foreach (FieldDescriptor fieldDescriptorin Messages.Descriptor.Fields.InDeclarationOrder()){ &amp;hellip;">
      
    

    
    
    <meta name="twitter:image" content="http://img.orvnge.com/uploads/2001/020846384380.png">
    
    

    

    
    




    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  
  <body class="blog">
    <header class="masthead">
      <h1><a href="/">wwnje</a></h1>

<p class="tagline">Life is casual.</p>

      <nav class="menu">
  <input id="menu-check" type="checkbox" />
  <label id="menu-label" for="menu-check" class="unselectable">
    <span class="icon close-icon">✕</span>
    <span class="icon open-icon">☰</span>
    <span class="text">Menu</span>
  </label>
  <ul>
  
  
  <li><a href="/blog/">blog</a></li>
  
  <li><a href="/categories/">categories</a></li>
  
  <li><a href="/tags/">tags</a></li>
  
  <li><a href="/about/">about</a></li>
  
  <li><a href="http://orvnge.com/Blog/">archive</a></li>
  
  
  </ul>
</nav>

    </header>

    <article class="main">
      <header class="title">
      
<h1>Protobuf Speed Optimization</h1>

<h3>wwnje
  /  2019-12-31</h3>
<hr>


      </header>



<p>optimization <code> Messages.Descriptor.Fields.InDeclarationOrder()</code></p>
<h2 id="original-code">Original Code</h2>
<h3 id="packetmap">PacketMap</h3>
<pre><code>public void Initialize()
{
    foreach (FieldDescriptor fieldDescriptor
        in Messages.Descriptor.Fields.InDeclarationOrder())
    {
        ushort messageType = (ushort)fieldDescriptor.FieldNumber;

        _messageTypes[fieldDescriptor.MessageType.ClrType] = messageType;
        _parsers[messageType] = fieldDescriptor.MessageType.Parser;
    }
}
</code></pre><blockquote>
<p>优化前的问题</p>
</blockquote>
<p>在游戏启动后直接加载中这段代码
<img src="http://img.orvnge.com/uploads/2001/020846384380.png" alt=""></p>
<p>可以看到这段代码耗时在User Code中占用了一半，在真机表现中，因为是在游戏启动后直接加载这段代码，所以在logo出现后会黑屏一会再出现loading界面。</p>
<h2 id="优化版本">优化版本</h2>
<p>代码耗时的最大原因是Protobuf的反射问题，所以能不能不用反射呢。优化方向有两个</p>
<ol>
<li>不放在游戏启动时进行，而是在loading时进行</li>
<li>不用反射</li>
</ol>
<p>下面是优化后的代码</p>
<h3 id="packetmaploader">PacketMapLoader</h3>
<pre><code>public class PacketMapLoader : ILaunchTask
{
    [Inject] private readonly IPacketMap _packetMap;

    public int ExecuteOrder =&gt; -1;

    public async UniTask Execute()
    {
        var stopwatch = new Stopwatch();
        stopwatch.Start();

        var messageTypes = new Dictionary&lt;Type, ushort&gt;();
        var parsers = new Dictionary&lt;ushort, MessageParser&gt;();

        var packetMapData = new PacketMapData();
        packetMapData.Init(messageTypes, parsers);
        _packetMap.InitMessages(messageTypes, parsers);

        stopwatch.Stop();
        Debug.LogFormat(
            $&quot;&lt;color=yellow&gt;PacketMapLoader Execute cost:{stopwatch.Elapsed.TotalMilliseconds}&lt;/color&gt;&quot;);
    }
}
</code></pre><p>再来看看时间是不是省了非常多，从500ms多到90ms。</p>
<p><img src="http://img.orvnge.com/uploads/2001/020849035551.png" alt=""></p>
<p>那么是怎么做到的呢，原因就是提前生成需要的代码来代替反射。这里大概有200多个网络消息，创建PacketMapData的代码我放最下面。</p>
<h3 id="packetmapdata">PacketMapData</h3>
<pre><code>public class PacketMapData
{ 
    public void Init(Dictionary&lt;Type, ushort&gt; messageTypes, Dictionary&lt;ushort, MessageParser&gt; parsers)
    {
        messageTypes.Add(typeof(Protocols.Messages.Login.LoginToLSReq), 1001);
        var parser1 = Protocols.Messages.Login.LoginToLSReq.Parser;
        parsers.Add(1001, parser1);
        ...
        ...
        messageTypes.Add(typeof(Protocols.Messages.Activity.NewYearBuyRes), 2601);
        var parser254 = Protocols.Messages.Activity.NewYearBuyRes.Parser;
        parsers.Add(2601, parser254);
    }
}
</code></pre><blockquote>
<p>不足</p>
</blockquote>
<p>但是实际上这段代码还是有不足的地方，比如loading开始时会有一点点卡顿。原因可以看以下Protobuf源码</p>
<p><img src="http://img.orvnge.com/uploads/2001/020849437095.png" alt=""></p>
<p>当我们每次获取消息的Parser时都会进行一遍new操作，比如</p>
<pre><code>var parser1 = Protocols.Messages.Login.LoginToLSReq.Parser;
</code></pre><p>而且我们有200多个消息，这也是可以优化的，优化方向就是异步处理。</p>
<h2 id="异步优化版本">异步优化版本</h2>
<p>优化的重点就是用异步来做，但是时间总耗时增加了很多，所以用哪个看项目需要。</p>
<h3 id="packetmaploader-1">PacketMapLoader</h3>
<pre><code>public class PacketMapLoader : ILaunchTask
{
    [Inject] private readonly IPacketMap _packetMap;

    public int ExecuteOrder =&gt; -1;

    public async UniTask Execute()
    {
        var stopwatch = new Stopwatch();
        stopwatch.Start();

        var messageTypes = new Dictionary&lt;Type, ushort&gt;();
        var parsers = new Dictionary&lt;ushort, MessageParser&gt;();

        var packetMapData = new PacketMapData();
        await UniTask.WhenAll(packetMapData.Init(messageTypes, parsers));
        _packetMap.InitMessages(messageTypes, parsers);

        stopwatch.Stop();
        Debug.LogFormat(
            $&quot;&lt;color=yellow&gt;PacketMapLoader Execute cost:{stopwatch.Elapsed.TotalMilliseconds}&lt;/color&gt;&quot;);
    }
}
</code></pre><h3 id="packetmapdata-1">PacketMapData</h3>
<pre><code>public class PacketMapData
{ 
    public async UniTask Init(Dictionary&lt;Type, ushort&gt; messageTypes, Dictionary&lt;ushort, MessageParser&gt; parsers)
    {
        messageTypes.Add(typeof(Protocols.Messages.Login.LoginToLSReq), 1001);
        var parser1 = Protocols.Messages.Login.LoginToLSReq.Parser;
        parsers.Add(1001, parser1);
        await UniTask.WaitUntil(() =&gt; parser1 != null);
        ...
        ...
        messageTypes.Add(typeof(Protocols.Messages.Activity.NewYearBuyRes), 2601);
        var parser254 = Protocols.Messages.Activity.NewYearBuyRes.Parser;
        parsers.Add(2601, parser254);
        await UniTask.WaitUntil(() =&gt; parser254 != null);

    }
}
</code></pre><p>这个异步优化代码也有可以优化的空间，每次都等异步太浪费了，增加了耗时，最好是打包几个消息确定具体时间后异步等对应时间可能会更好。</p>
<h2 id="packetmapcreatecs">PacketMapCreate.cs</h2>
<pre><code>[MenuItem(&quot;Tools/PacketMapCreate&quot;)]
public static void Create()
{
    var csText = Header;
    var index = 0;
    foreach (FieldDescriptor fieldDescriptor
        in Messages.Descriptor.Fields.InDeclarationOrder())
    {
        csText += $&quot;\t\t\tmessageTypes.Add(typeof({fieldDescriptor.MessageType.ClrType.FullName}), {fieldDescriptor.FieldNumber});\n&quot;;
        var parser = $&quot;parser{++index}&quot;;
        csText += $&quot;\t\t\tvar {parser} = {fieldDescriptor.MessageType.ClrType.FullName + &quot;.Parser&quot;};\n&quot;;
        csText += $&quot;\t\t\tparsers.Add({fieldDescriptor.FieldNumber}, {parser});\n&quot;;
//                csText += $&quot;\t\t\tawait UniTask.WaitUntil(() =&gt; {parser} != null);\n&quot;;
        csText += &quot;\n&quot;;
    }

    csText += Bottom;
    var path = Path.Combine(Application.dataPath, &quot;PuzzlesKingdom/Scripts/PacketMap/PacketMapData.cs&quot;);
    File.WriteAllText(path, csText);
}
</code></pre>

  <footer>
  
  



<script src="//cdn.bootcss.com/highlight.js//highlight.min.js"></script>



<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



  
  <hr>
  <div class="copyright">© <a href="https://orvnge.com">wwnje</a> 2020 | <a href="https://github.com/wwnje">Github</a> | <a href="https://space.bilibili.com/4480216">Bilibili</a></div>
  
  </footer>
  </article>
  
  </body>
</html>

